# LIVRABLE SÉANCE 9 : Design Patterns Comportementaux

**Document :** Moteur de Règles (Strategy & Decorator)

## 1. Objectif : Rendre l'application dynamique

L'objectif est de permettre l'exécution de règles métier variables et combinables sans modifier le code structurel des objets du domaine.

## 2. Implémentation du Pattern Strategy (Règles Métier)

Nous avons isolé les règles de calcul dans des classes dédiées implémentant l'interface `IRule`.

*   **Interface :** `com.jad.rule.IRule` définit la méthode `int apply(Foo foo)`.
*   **Stratégies Concrètes :**
    *   `BazCountRule` : Calcule un score basé sur le nombre de `Baz`.
    *   `GraultCountRule` : Calcule un score basé sur le nombre de `Grault`.

Cela permet de changer l'algorithme de calcul de score à la volée.

## 3. Implémentation du Pattern Decorator (Enrichissement)

Pour modifier dynamiquement le comportement d'une règle (ex: ajouter un bonus, doubler les points), nous avons utilisé le pattern **Decorator**.

*   **Abstrait :** `RuleDecorator` implémente `IRule` et contient une référence vers une autre `IRule`.
*   **Concrets :**
    *   `BonusRuleDecorator` : Ajoute une valeur fixe au résultat.
    *   `DoubleRuleDecorator` : Multiplie le résultat par deux.

Exemple de composition dynamique :
```java
// Une règle qui compte les Baz, ajoute 10 points, puis double le tout
IRule complexRule = new DoubleRuleDecorator(
                        new BonusRuleDecorator(
                            new BazCountRule(), 10
                        )
                    );
```

## 4. Moteur de Règles

La classe `RuleEngine` permet d'agréger et d'exécuter un ensemble de règles sur un objet `Foo`, fournissant ainsi un moteur de calcul flexible.

## 5. Livrables

*   ✅ **Moteur de règles** : Package `com.jad.rule` complet.
*   ✅ **Tests Unitaires** : `src/test/java/com/jad/rule/RuleTest.java` validant les stratégies et leur décoration.
