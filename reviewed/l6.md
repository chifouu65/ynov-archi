# LIVRABLE SÉANCE 6 : Design Patterns de Création

**Document :** Implémentation Factory & Builder

## 1. Objectif : Centraliser l'Instanciation

L'objectif de cette séance était de sortir la logique de création d'objets (instanciation) du code métier pour la centraliser. Cela permet de réduire le couplage fort induit par l'opérateur `new` et facilite l'évolution et les tests.

## 2. Implémentation du Pattern Factory (Singleton)

Nous avons créé une classe `Factory` centrale (`com.jad.Factory`) qui est désormais le point d'entrée unique pour créer les entités du domaine (`Foo`, `Bar`, `Baz`, `Qux`, `Corge`, `Grault`).

### 2.1. Choix du Singleton

La Factory est implémentée en tant que **Singleton**.

*   **Principe :** Assurer qu'une seule instance de la factory existe pour toute l'application.
*   **Pourquoi ?** Cela centralise la configuration de création. Si demain nous devons changer la façon dont les `Foo` sont créés (ex: injection de dépendance, pool d'objets), nous ne modifions que cette classe unique.
*   **Code :**
    ```java
    public static Factory getInstance() {
        if (instance == null) {
            instance = new Factory();
        }
        return instance;
    }
    ```

### 2.2. Utilisation

Au lieu de faire `new Qux()`, le code (comme dans `Foo.java`) appelle désormais :
```java
this.qux = Factory.getInstance().createQux();
```

## 3. Implémentation du Pattern Builder

Pour gérer la construction d'objets complexes comme `Foo`, qui possède plusieurs dépendances et associations (Bar, Qux, liste de Baz...), nous avons introduit un **Builder** (`FooBuilder`).

### 3.1. Avantages

Le pattern Builder permet de :
1.  Construire un objet complexe étape par étape.
2.  Rendre le code client plus lisible (interface fluide / Fluent Interface).
3.  Éviter les constructeurs télescopiques (constructeurs avec trop de paramètres).

### 3.2. Exemple d'utilisation

Via la Factory qui expose le Builder :
```java
// Construction fluide
Foo foo = Factory.getInstance().createFooBuilder(bar)
              .withQux(qux)
              .addBaz(baz1)
              .addBaz(baz2)
              .build();
```

## 4. Travail Réalisé & Validation

*   **Refactoring de `Foo` :** La classe `Foo` n'instancie plus ses dépendances directement via `new`, mais délègue à la `Factory`.
*   **Mise à jour des Tests :** `FooTest` a été réécrit pour utiliser la `Factory`. Tous les tests passent, garantissant que le comportement métier est préservé malgré le changement architectural.
*   **Nettoyage :** Le code respecte les principes de responsabilité unique (SRP) : `Foo` gère ses données, `Factory` gère la création.

## 5. Livrables

*   ✅ **Factory globale fonctionnelle** : `src/main/java/com/jad/Factory.java`
*   ✅ **Singleton / Builder** : Implémentés et intégrés.
